import React from 'react';
import { fromJS } from 'immutable';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { useSelector } from 'react-redux';
import { useFetchye } from 'fetchye';
import ProgramForm from '../../../src/components/OnBoardProgram/ProgramForm';

jest.mock('fetchye', () => ({
  useFetchye: jest.fn(),
}));

jest.mock('formik', () => {
  const original = jest.requireActual('formik');
  return {
    ...original,
    useFormik: jest.fn(),
  };
});

jest.mock('react-redux', () => ({
  ...jest.requireActual('react-redux'),
  useSelector: jest.fn(),
}));

const mockRun = jest.fn();

const mockAppState = fromJS({
  config: {
    oneApiUrl: 'http://localhost',
  },
});

const initialValues = {
  org: '',
  product: '',
  typeOfExtraction: '',
  epics: [],
  capabilities: [],
  platforms: [],
  container: [],
};

const mockSetFieldValue = jest.fn();
const mockResetForm = jest.fn();

beforeEach(() => {
  jest.clearAllMocks();
  useSelector.mockImplementation(cb => cb(mockAppState));
  useFetchye.mockReturnValue({
    error: null,
    isLoading: false,
    data: null,
    ok: null,
    run: mockRun,
  });

  require('formik').useFormik.mockReturnValue({
    values: { ...initialValues },
    errors: {},
    handleChange: jest.fn(),
    handleSubmit: jest.fn(e => e.preventDefault()),
    isSubmitting: false,
    isValid: true,
    dirty: true,
    resetForm: mockResetForm,
    setFieldValue: mockSetFieldValue,
  });
});

describe('ProgramForm', () => {
  it('renders form fields correctly', () => {
    render(<ProgramForm orgName="Test Org" />);
    expect(screen.getByTestId('handleorg')).toBeInTheDocument();
    expect(screen.getByTestId('handleproduct')).toBeInTheDocument();
    expect(screen.getByTestId('onsubmit')).toBeInTheDocument();
  });

  it('calls onBoardProgram success flow', async () => {
    useFetchye.mockReturnValueOnce({
      error: null,
      isLoading: false,
      data: { success: true },
      ok: true,
      run: jest.fn().mockResolvedValue({ success: true }),
    });

    render(<ProgramForm />);

    fireEvent.submit(screen.getByTestId('onsubmit'));

    await waitFor(() => {
      expect(screen.getByText(/Added successfully/i)).toBeInTheDocument();
    });
  });

  it('calls onBoardProgram error flow', async () => {
    useFetchye.mockReturnValueOnce({
      error: null,
      isLoading: false,
      data: { success: false },
      ok: false,
      run: jest.fn().mockResolvedValue({ success: false }),
    });

    render(<ProgramForm />);

    fireEvent.submit(screen.getByTestId('onsubmit'));

    await waitFor(() => {
      expect(
        screen.getByText(/Some problem happened while adding/i)
      ).toBeInTheDocument();
    });
  });

  it('closes alert when cancel button is clicked', async () => {
    useFetchye.mockReturnValueOnce({
      error: null,
      isLoading: false,
      data: { success: true },
      ok: true,
      run: jest.fn().mockResolvedValue({ success: true }),
    });

    render(<ProgramForm />);
    fireEvent.submit(screen.getByTestId('onsubmit'));

    await waitFor(() =>
      expect(screen.getByTestId('showAlert')).toBeInTheDocument()
    );

    fireEvent.click(screen.getByTestId('showAlert'));
  });

  it('changes typeOfExtraction to enable dropdowns', async () => {
    const mockHandleChange = jest.fn();
    require('formik').useFormik.mockReturnValueOnce({
      ...require('formik').useFormik(),
      values: { ...initialValues, typeOfExtraction: 'epics' },
      handleChange: mockHandleChange,
    });

    render(<ProgramForm />);
    const select = screen.getByTestId('handleextraction');
    fireEvent.change(select, { target: { value: 'Containers' } });
    expect(mockHandleChange).toHaveBeenCalled();
  });

  it('handles dropdown changes for epics, capabilities, platforms, container', () => {
    render(<ProgramForm />);
    fireEvent.change(screen.getByTestId('handleepic'), {
      target: { value: 'Epic1' },
    });
    fireEvent.change(screen.getByTestId('handlecapability'), {
      target: { value: 'Cap1' },
    });
    fireEvent.change(screen.getByTestId('handleplatform'), {
      target: { value: 'Plat1' },
    });
    fireEvent.change(screen.getByTestId('handlecontainer'), {
      target: { value: 'Cont1' },
    });
  });

  it('disables submit button when form is invalid', () => {
    require('formik').useFormik.mockReturnValueOnce({
      ...require('formik').useFormik(),
      isValid: false,
    });
    render(<ProgramForm />);
    expect(screen.getByTestId('onsubmit')).toBeDisabled();
  });
});
