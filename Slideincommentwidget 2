it('fetches comments again when postedComment or postedReply is truthy', () => {
  let callCount = 0;
  mockUseApp.mockImplementation(() => {
    callCount++;
    if (callCount % 3 === 1) {
      return { isLoading: false, data: { body: [] }, run: getCommentsMock };
    }
    if (callCount % 3 === 2) {
      // postComment with truthy data to trigger effect
      return { isLoading: false, data: { body: ['ok'] }, run: postCommentMock };
    }
    // postReply with falsy
    return { isLoading: false, data: { body: [] }, run: postReplyMock };
  });

  mockUseComments.mockReturnValue({
    isOpen: true,
    closeComments: mockCloseComments,
    payload: { id: 1 },
  });

  render(<SlideInCommentsWidget />);

  // After initial render, useEffect sees postedComment truthy â†’ calls getComments again
  expect(getCommentsMock).toHaveBeenCalledTimes(2); // initial + effect
});
////////////////////////////////=//
beforeEach(() => {
  jest.clearAllMocks();

  getCommentsMock = jest.fn();
  postCommentMock = jest.fn();
  postReplyMock = jest.fn();

  mockUseComments.mockReturnValue({
    isOpen: true,
    closeComments: mockCloseComments,
    payload: { id: 1 },
  });

  // Return mocks in exact call order for the first render
  let callCount = 0;
  mockUseApp.mockImplementation(() => {
    callCount++;
    if (callCount === 1) {
      return { isLoading: false, data: { body: [] }, run: getCommentsMock };
    }
    if (callCount === 2) {
      return { isLoading: false, run: postCommentMock };
    }
    if (callCount === 3) {
      return { isLoading: false, run: postReplyMock };
    }
    // Any later calls (due to re-renders) still return safe default
    return { isLoading: false, run: jest.fn(), data: { body: [] } };
  });
});




// SlideInCommentsWidget.spec.tsx
import React from 'react';
import { render, screen, fireEvent, act } from '@testing-library/react';
import SlideInCommentsWidget from './SlideInCommentsWidget';

// Mock hooks and dependencies
jest.mock('@americanexpress/one-insight-toolkit', () => ({
  SlideInComments: jest.fn(({ onCloseBtnClick, onSubmitBtnClick, onReplyBtnClick }) => (
    <div>
      <button onClick={onCloseBtnClick}>close</button>
      <button onClick={() => onSubmitBtnClick('new comment')}>submit</button>
      <button onClick={() => onReplyBtnClick('reply text', { commentId: 123 })}>reply</button>
    </div>
  )),
  objToQueryParams: jest.fn(() => 'mockQuery'),
}));

const mockUseApp = jest.fn();
jest.mock('../hooks/useAuthData', () => ({
  useApp: () => mockUseApp(),
}));

const mockCloseComments = jest.fn();
const mockUseComments = jest.fn();
jest.mock('../contexts/CommentsContext', () => ({
  useComments: () => mockUseComments(),
}));

describe('SlideInCommentsWidget', () => {
  let getCommentsMock: jest.Mock;
  let postCommentMock: jest.Mock;
  let postReplyMock: jest.Mock;

  beforeEach(() => {
    jest.clearAllMocks();

    getCommentsMock = jest.fn();
    postCommentMock = jest.fn();
    postReplyMock = jest.fn();

    // Default mocks for hooks
    mockUseComments.mockReturnValue({
      isOpen: true,
      closeComments: mockCloseComments,
      payload: { id: 1 },
    });

    mockUseApp
      // useApp for getComments
      .mockReturnValueOnce({
        isLoading: false,
        data: { body: [] },
        run: getCommentsMock,
      })
      // useApp for postComment
      .mockReturnValueOnce({
        isLoading: false,
        run: postCommentMock,
      })
      // useApp for postReplyComment
      .mockReturnValueOnce({
        isLoading: false,
        run: postReplyMock,
      });
  });

  it('renders and closes comments on button click', () => {
    render(<SlideInCommentsWidget />);

    fireEvent.click(screen.getByText('close'));
    expect(mockCloseComments).toHaveBeenCalled();
  });

  it('calls setComment and triggers postComment useEffect', () => {
    jest.useFakeTimers();
    render(<SlideInCommentsWidget />);
    fireEvent.click(screen.getByText('submit'));
    act(() => {
      jest.runAllTimers();
    });
    expect(postCommentMock).toHaveBeenCalled();
  });

  it('calls setReply and triggers postReply useEffect', () => {
    jest.useFakeTimers();
    render(<SlideInCommentsWidget />);
    fireEvent.click(screen.getByText('reply'));
    act(() => {
      jest.runAllTimers();
    });
    expect(postReplyMock).toHaveBeenCalled();
  });

  it('fetches comments when isOpen and payload change', () => {
    render(<SlideInCommentsWidget />);
    expect(getCommentsMock).toHaveBeenCalled();
  });

  it('renders empty messages array when data.body is not an array', () => {
    mockUseApp
      .mockReturnValueOnce({
        isLoading: false,
        data: { body: {} }, // Not an array
        run: getCommentsMock,
      })
      .mockReturnValueOnce({
        isLoading: false,
        run: postCommentMock,
      })
      .mockReturnValueOnce({
        isLoading: false,
        run: postReplyMock,
      });

    render(<SlideInCommentsWidget />);
    expect(getCommentsMock).toHaveBeenCalled();
  });
});
